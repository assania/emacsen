#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -*- mode: python -*-

from __future__ import with_statement
from __future__ import absolute_import

import socket
import shutil
try:
    import cPickle as pickle
except ImportError:
    import pickle
import protocols
import random
import protocols.exception
import subprocess
import protocols.util
import protocols.status
import protocols.labels
import traceback
import sys
import mapnik
import csv
import operator
import render
import math
import time
import logging
import logging.config
import logging.handlers
try:
    import cStringIO as StringIO
except ImportError:
    import StringIO
import fibra
import fibra.net
import os
import gc
try:
    import json
except ImportError:
    import simplejson as json
import Image, ImageDraw, ImageEnhance
import aggdraw
import argparse


COPYRIGHT = [u'Rendering © %d CloudMade' % time.localtime()[0],
             u'Data © %d CCBYSA osm.org' % time.localtime()[0]]

fibra.net.MAX_FRAME_SIZE = 10**10
fibra.net.DEFAULT_TIMEOUT = 30.0
fibra.net.BUFFER_SIZE = 1024

config = render.config.Config('/etc/renderd/settings.ini')

STYLES = {}
ICONINFO = {}

projection = mapnik.Projection("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 "
                               "+lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m "
                               "+nadgrids=@null +no_defs +over")
logger = logging.getLogger('render.base')

styles = render.styles.Styles(config)

def form_logging_key(request):
    tile_size = request['tile_size']
    styleid = request['styleid']
    x = request['x']
    y = request['y']
    zoom = request['zoom']
    return '/'.join(map(str, [styleid, tile_size, zoom, x, y]))

class SocketBroke(Exception):
    pass

class StyleError(Exception):
    pass

def handle_style_timestamp(addr, request):
    timestamp = request['timestamp']
    styleid = request['styleid']
    try:
        style_timestamp = STYLES[styleid]['timestamp']
        if timestamp < style_timestamp + 0.1:
            return
    except KeyError:
        pass
    style_request = pickle.dumps(dict(label=protocols.labels.style,
                                      styleid=styleid))
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((config['farmd.address'], int(config['farmd.port'])))
        sock.setblocking(0)
        protocols.util.send_frame(sock, style_request)
        response = protocols.util.recv_frame(sock)
        sock.close()
        response = pickle.loads(response)
        if response['status'] == protocols.status.SUCCESS:
            start = time.time()
            template = response['data']
            tile_style = render.utils.tile.parse(template)
            icon_style = render.utils.icon.parse(template)
            print "%.4f | %.4f | parsing xml" % (time.time(), (time.time() - start))
            with open('/tmp/%s-parsed.xml' % styleid, 'w') as f:
                f.write(tile_style)
            STYLES[styleid] = {'xml': template, 'icon_template': icon_style,
                               'tile_template': tile_style, 'timestamp': timestamp}
        else:
            raise StyleError
    except protocols.exception.SocketClosed:
        raise StyleError 

def bbox_from_coords(*args):
    bbox = mapnik.Envelope(*map(projection.forward, args))

def bbox_from_doubles(*args):
    return bbox_from_coords(*map(mapnik.Coord, [args[:2], args[2:]]))
        
def tilenums2latlon(xtile, ytile, zoom):
    """Convert tile coordinates pair to latitude, longitude"""
    factor = 2.0 ** zoom
    lon = (xtile * 360 / factor) - 180.0
    lat = math.atan(math.sinh(math.pi * (1 - 2 * ytile / factor)))
    return math.degrees(lat), lon

def get_tile_style(request):
    map_ = styles.tile(request['styleid'], request['timestamp'])
    if hillshading_support(map_):
        print "injecting hillshading"
        inject_hillshading(map_, request)
    return map_

def inject_hillshading(style, request):
    if request['meta_size'] == 2:
        #hillshading layer lookup
        for index, layer in enumerate(style.layers):
            if layer.name == 'raster-hillshading':
                hs_layer = layer
                break
        else:	
            hs_layer = mapnik.Layer('raster-hillshading',
                                    ("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0"
                                    "+lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m "
                                    "+nadgrids=@null +no_defs +over"))
            hs_layer.styles.append('raster')
            layers = list(style.layers[:])
            while style.layers:
                del style.layers[0]
            style.layers.append(hs_layer)
            style.layers.extend(layers)
            index = 0
        tile_size = request['tile_size']
        meta_size = request['meta_size']
        x = request['x']
        y = request['y']
        zoom = request['zoom']
        border = request['border']
        size_mod = border * 2 / tile_size
        coords = [(x, y), (x + meta_size, y + meta_size)]
        coords = [[offset * float(tile_size) for offset in coord] for coord in coords]
        coords = [pixel2latlon(coord, zoom, tile_size) for coord in coords]
        coords = [mapnik.Coord(*coord) for coord in coords]
        coords = [projection.forward(coord) for coord in coords]
        bbox = mapnik.Envelope(*coords)
        for dimension in (bbox.height, bbox.width):
            dimension(dimension() * (1 + size_mod / float(meta_size)))
        path = ramp_path(request)
        hs_layer.datasource = mapnik.Raster(file=path,
                                            lox=bbox.minx, loy=bbox.miny,
                                            hix=bbox.maxx, hiy=bbox.maxy)
                
def ramp_path(request):
    hash_ = range(5)
    x = request['x']
    y = request['y']
    meta_count = 2
    
    # Each meta tile winds up in its own file, with several in each leaf directory
    # the .meta tile name is based on the sub-tile at (0,0)
    
    mask = meta_count-1
    offset = ((x & mask) * meta_count) + (y & mask)
    x &= ~mask
    y &= ~mask
    for i in xrange(5):
        hash_[i] = ((x & 0x0f) << 4) | (y & 0x0f)
        x >>= 4
        y >>= 4
    meta_path = os.path.join(config.get('hillshading.ramp', '/mnt-ps/var/hs'), "256", str(request['zoom']),
                             *map(str, reversed(hash_))) + '.meta'
    tif_path = meta_path + '.tif'
    if not os.path.exists(tif_path):
	png_path = meta_path + '.png'
	if os.path.exists(png_path):
	    res = os.system('convert %s %s' % (png_path, tif_path))
	    if res is 0:
		res = os.system('rm %s', png_path)
		if res is 0:
		    print 'PNG dropped: %s' % png_path
    return tif_path

def hillshading_support(style):
    try:
        style.find_style('raster')
    except KeyError:
        return False
    return True

def get_staticmaps_style(request):
    return styles.staticmaps(request['styleid'], request['timestamp'])

def get_icon_style(request):
    map_ = styles.icon(request['styleid'], request['timestamp'])
    info = ICONINFO[request['zoom']]
    width, height = info['w'], info['h']
    map_.resize(width, height)
    return map_

def icon_split(image, zinfo):
    for x in xrange(0, zinfo['w'], 64):
        for y in reversed(xrange(0, zinfo['h'], 64)):
            xpp = (64 - 28) / 2
            ypp = (64 - 18) / 2
            yield image.view(x + xpp, y + ypp, 28, 18).tostring('png')
            

def icon(request):
    map_ = get_icon_style(request)
    zinfo = ICONINFO[request['zoom']]
    p0x = zinfo['lon']
    p0y = zinfo['lat']
    p1x = zinfo['wlon']
    p1y = zinfo['wlat']
    p0 = projection.forward(mapnik.Coord(p0x, p0y))
    p1 = projection.forward(mapnik.Coord(p1x, p1y))
    bbox = mapnik.Envelope(p0.x, p0.y, p1.x, p1.y)
    map_.zoom_to_box(bbox)
    image = mapnik.Image(int(zinfo['w']), int(zinfo['h']))
    mapnik.render(map_, image)
    data = pickle.dumps(list(icon_split(image, zinfo)))
    return pickle.dumps(dict(status=protocols.status.SUCCESS,
                           timestamp=time.time(),
                           data=data))
    
def tile(request):
    """
    Render tile

    Rendering tile is not an easy task by any means.
    One of the biggest problems is label trimming.
    Labels are quite often abused by mapnik's render
    when they cross the border of the tile, which
    results in not so pretty view. To avoid this
    issue, additional data should be fetched from
    PostGIS DB. The amount of data is determined by
    'border' parameter of the request. Value of this
    parameter is the width (in pixels) of additional
    square around the tile that should be downloaded.
    An attempt at illustration is given below:

    ***************************
    *                ^        *
    *         Border |        *    
    *                v        *    
    *       |---------|       *    
    *       |         |       *    
    *       |  Tile   |       *    
    *       |         |       *    
    *       |---------|       *    
    *                         *    
    *                         *    
    *                         *    
    ***************************
    
    
    We don't render just one tile at a moment, we
    render the so-called meta-tile, which consists
    of several regular tiles. This is done because
    most tiles are being requested in big bounding
    boxes and rendering them one by one would be highly
    ineffective because of the amount of redundant data
    used for borders.
    Converting tile numbers to Merkaartor projection
    is done through intermediate step that converts
    tile numbers or, rather, pixel offsets to latitude,
    longitude pairs which are converted to Merkaartor
    projection using mapnik.Projection()
    This is quite standard fiddling for Mapnik and one
    shouldn't seek for any bottlenecks here.
    Main bottleneck of this function right now is
    mapnik.render() function, which takes around 90% of
    the time.
    """
    print "%.4f | %s | tile request" % (time.time(), form_logging_key(request))
    tile_size = request['tile_size']
    meta_size = request['meta_size']
    x = request['x']
    y = request['y']
    zoom = request['zoom']
    border = request['border']
    size_mod = border * 2 / tile_size
    coords = [(x, y), (x + meta_size, y + meta_size)]
    coords = [[offset * float(tile_size) for offset in coord] for coord in coords]
    coords = [pixel2latlon(coord, zoom, tile_size) for coord in coords]
    coords = [mapnik.Coord(*coord) for coord in coords]
    coords = [projection.forward(coord) for coord in coords]
    bbox = mapnik.Envelope(*coords)
    for dimension in (bbox.height, bbox.width):
        dimension(dimension() * (1 + size_mod / float(meta_size)))
    side = request['tile_size'] * request['meta_size'] + request['border'] * 2
    map_ = get_tile_style(request)
    map_.resize(side, side)
    map_.zoom_to_box(bbox)
    side = tile_size * (meta_size + size_mod)
    image = mapnik.Image(side, side)
    try:
        print "%.4f | %s | preparing done" % (time.time(), form_logging_key(request))
        mapnik.render(map_, image)
        print "%.4f | %s | render done" % (time.time(), form_logging_key(request))
        data = dict(split_image(image, request, tile_size, meta_size))
        print "%.4f | %s | splitting done" % (time.time(), form_logging_key(request))
        try:
            return pickle.dumps(dict(status=protocols.status.SUCCESS,
                                     timestamp=time.time(),
                                     data=data))
        finally:
            print "%.4f | %s | packing done" % (time.time(), form_logging_key(request))            
    except Exception, exc:
        traceback.print_exc()
        print "Got exception for style %s: %s" % (request['styleid'], exc)
    return pickle.dumps(dict(status=protocols.status.NOTIMPLEMENTED))

def split_image(image, request, tile_size, meta_size):
    """Split big image into tiles"""
    tile_size = request['tile_size']
    meta_size = request['meta_size']
    border = request['border']
    rendering_type = request['rendering_type'].encode('utf8')
    for horizontal_offset in xrange(0, meta_size):
        for vertical_offset in xrange(0, meta_size):
            view = image.view(int(horizontal_offset * tile_size + border),
                              int(vertical_offset * tile_size + border),
                              tile_size, tile_size)
            yield (protocols.util.tile_label_with_offset(request,
                                                         horizontal_offset,
                                                         vertical_offset),
                   view.tostring(rendering_type))

def pixel2latlon(coords, zoom, tile_size=256):
    tile_size = float(tile_size)
    e = tile_size * 2**(zoom - 1)
    g = (e - coords[1]) * 2 * math.pi / (tile_size * 2**zoom)
    lat = (coords[0] - e) / ((tile_size * 2**zoom) / 360.0)
    lon = math.degrees((2 * math.atan(math.exp(g))) - (0.5 * math.pi))
    return lat, lon

def determine_bbox(paths, markers):
    coords = []
    paths = paths['geometries']
    for path in paths:
        if path['type'] == 'LineString':
            coords.extend(path['coordinates'])
        else:
            coords.extend(path['coordinates'][0])
    for marker in markers:
        coords.append(marker['coordinate'])
    buff = 0.1
    coords = [min(map(operator.itemgetter(0), coords)),
              min(map(operator.itemgetter(1), coords)),
              max(map(operator.itemgetter(0), coords)),
              max(map(operator.itemgetter(1), coords))]
    lon_buff = abs(coords[2] - coords[0]) * buff
    lat_buff = abs(coords[3] - coords[1]) * buff
    if lat_buff < 0.0001:
        lat_buff = 0.0001
    if lon_buff < 0.0001:
        lon_buff = 0.0001
    coords = [mapnik.Coord(coords[0] - lon_buff, coords[1] - lat_buff),
              mapnik.Coord(coords[2] + lon_buff, coords[3] + lat_buff)]
    return coords


def staticmaps(request):
    width, height = request['size']
    print "%.4f | staticmap | rendering" % time.time()
    fmt = request['fmt']
    image = stitch(request)
    image = addpaths(image, request['paths'])
    image = addmarkers(image, request['markers'])
    fmt = {'png': 'PNG8',
           'png8': 'PNG8',
           'png32': 'PNG',
           'jpg': 'JPEG',
           'jpeg': 'JPEG',
           'gif': 'GIF'}
    fmt = fmt[request['fmt']]
    kwargs = {}
    if fmt == 'PNG8':
        image = image.convert('RGB').convert('P', dither=None, palette=Image.ADAPTIVE)
        fmt = 'PNG'
    out = StringIO.StringIO()
    image.save(out, fmt, **kwargs)
    image = out.getvalue()
    return pickle.dumps(dict(status=protocols.status.SUCCESS,
                             timestamp=time.time(),
                             data=image),
                        pickle.HIGHEST_PROTOCOL)


def stitch(request):
    base = Image.new('RGBA', tuple(request['size']))
    styleid = request['styleid']
    zoom = request['zoom']
    for (xtile, ytile), bbox in request['tiles']:
        image = fetch(xtile, ytile, request['zoom'], styleid)
        image = StringIO.StringIO(image)
        image = Image.open(image)
        image = image.crop(bbox)
        bbox = ((bbox[0] + xtile * 256 - request['topleft'][0]),
                (bbox[1] + ytile * 256 - request['topleft'][1]),
                (bbox[2] + xtile * 256 - request['topleft'][0]),
                (bbox[3] + ytile * 256 - request['topleft'][1]))
        base.paste(image, bbox)
    return base


def fetch(xtile, ytile, zoom, styleid):
    message = pickle.dumps(dict(label=protocols.labels.tile,
                                styleid=str(styleid),
                                x=int(xtile),
                                y=int(ytile),
                                meta_size=min(1 << int(zoom), 2),
                                tile_size=256,
                                zoom=int(zoom),
                                priority=0))
    while True:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((config['farmd.address'], int(config['farmd.port'])))
        try:
            # sock.setblocking(0)
            protocols.util.send_frame(sock, message)
            response = protocols.util.recv_frame(sock)
            response = pickle.loads(response)
            if response['status'] == protocols.status.SUCCESS:
                return response['data']
        except Exception:
            traceback.print_exc()
        finally:
            sock.close()
        print 'Getting tile failed for some reason'


def addmarkers(baseimage, markers):
    path = '/tmp/%s/' % random.random()
    os.mkdir(path)
    try:
        for marker in markers:
            label, width, height = marker['image']
            label = Image.open(StringIO.StringIO(label))
            label = label.convert('RGBA')
            opacity = marker['opacity']
            coord = list(marker['coordinate'])
            alpha = label.split()[3]
            alpha = ImageEnhance.Brightness(alpha).enhance(opacity)
            label.putalpha(alpha)
            coord[0] = coord[0] - (width / 2)
            coord[1] = coord[1] - height
            baseimage.paste(label, tuple(coord), label)
        return baseimage
    finally:
        shutil.rmtree(path)


def flatten(seq):
    return tuple(x for y in seq for x in y)


def addpaths(baseimage, paths):
    draw = aggdraw.Draw(baseimage)
    for geometry, info in paths:
        geomtype = info['type']
        if geomtype == 'line':
            opacity = int(min(255, info['opacity'] * 256))
            pen = aggdraw.Pen(info['color'], info['weight'], opacity)
            draw.line(flatten(geometry), pen)
        elif geomtype == 'polygon':
            opacity = int(min(255, info['fill-opacity'] * 256))
            brush = aggdraw.Brush(info['fill'], opacity)
            draw.polygon(flatten(geometry), brush)
        else:
            pass
    draw.flush()
    return baseimage


def togif(data):
    path = '/tmp/%s' % random.random()
    pngpath = path + '.png'
    gifpath = path + '.gif'
    with open(pngpath, 'w') as tmp:
        tmp.write(data)
    subprocess.call(['convert', pngpath, gifpath])
    os.remove(pngpath)
    data = open(gifpath).read()
    os.remove(gifpath)
    return data

def normalize_bbox(map_, bbox):
    coef = 1001.0 / map_.scale_denominator()
    if 1001.0 / map_.scale_denominator() >= 1:
        height = bbox.height()
        width = bbox.width()
        minx = bbox.minx + (width / 2.0) - (width * coef / 2.0)
        maxx = bbox.maxx - (width / 2.0) + (width * coef / 2.0)
        miny = bbox.miny + (height / 2.0) - (height * coef / 2.0)
        maxy = bbox.maxy - (height / 2.0) + (height * coef / 2.0)
        map_.zoom_to_box(mapnik.Envelope(minx, miny, maxx, maxy))

def validate_coords(coords):
    for coord in coords:
        coord.x = min(max(coord.x, -179.999), 179.999)
        coord.y = min(max(coord.y, -84.999), 84.999)



def add_markers(map_, markers, tempdir):
    for marker in markers:
        try:
            image, width, height = marker['image']
            path = os.path.join(tempdir, str(random.random()) + '.png')
            with open(path, 'w') as f:
                f.write(image)
            coord = mapnik.Coord(*marker['coordinate'])
            coord = projection.forward(coord)
            datasource = mapnik.PointDatasource()
            datasource.add_point(coord.x, coord.y, 'Name', 'Some marker')
            symbolizer = mapnik.PointSymbolizer(path, 'png', width, int(height * 2))
            symbolizer.allow_overlap = True
            symbolizer.opacity = marker['opacity']
            rule = mapnik.Rule()
            rule.symbols.append(symbolizer)
            style = mapnik.Style()
            style.rules.append(rule)
            name = str(random.random())
            layer = mapnik.Layer(name, map_.srs)
            layer.datasource = datasource
            layer.styles.append(name)
            map_.append_style(name, style)
            map_.layers.append(layer)
        except Exception:
            traceback.print_exc()
    return map_

def get_marker_size(size):
    dispatch = {'mid': (23, 26),
                'small': (13, 15),
                'big': (33, 36)}
    return dispatch[size]

def get_path():
    base = '/tmp'
    return os.path.join(base, str(random.random()) + '.json')

def forward_raw_coord(coord):
    coord = mapnik.Coord(*coord)
    coord = projection.forward(coord)
    return [coord.x, coord.y]

def add_paths(map_, paths):
    for index, path in enumerate(paths['geometries']):
        filepath = get_path()
        # this hack is due to bug #7989
        # we just reproject from WGS84 to EPSG:900913 as a workaround
        if path['type'] == 'LineString':
            path['coordinates'] = map(forward_raw_coord, path['coordinates'])
            stroke = mapnik.Stroke()
            stroke.opacity = path['opacity']
            stroke.width = path['weight']
            stroke.color = mapnik.Color(path['color'].replace('0x', '#'))
            symbolizer = mapnik.LineSymbolizer(stroke)
        elif path['type'] == 'Polygon':
            path['coordinates'] = [map(forward_raw_coord, path['coordinates'][0])]
            symbolizer = mapnik.PolygonSymbolizer(mapnik.Color(path['fill'].replace('0x', '#')))
            symbolizer.fill_opacity = path['fill_opacity']
        with open(filepath, 'w') as ogr:
            json.dump(path, ogr)
        rule = mapnik.Rule()
        rule.symbols.append(symbolizer)
        style = mapnik.Style()
        style.rules.append(rule)
        map_.append_style(('Paths%d' % index), style)
        layer = mapnik.Layer(('Paths%d' % index), map_.srs)
        datasource = mapnik.Ogr(file=filepath, layer='OGRGeoJSON')
        layer.datasource = datasource
        layer.styles.append(('Paths%d' % index))
        map_.layers.append(layer)

    
def add_copy(image, size, fmt):
    fontdir = config.get('mapnik.fonts', '/usr/lib/mapnik/fonts')
    font = ImageFont.truetype(os.path.join(fontdir, 'AtariSmall.ttf'), 8)
    image = Image.open(StringIO.StringIO(image))
    draw = ImageDraw.Draw(image)
    if size[0] < 225:
        ## copyright = Image.open('/home/mishok/work/tileserver/mainline/render/rectangle-copyright.png')
        ## image.paste(copyright, (5, size[1] - 23))
        draw.rectangle([5, size[1] - 23,
                        110, size[1] - 5],
                       fill=0xff)
        for index, line in enumerate(COPYRIGHT):
            draw.text((5, size[1] - 23 + index * 9), line, font=font)
    else:
        ## copyright = Image.open('/home/mishok/work/tileserver/mainline/render/long-copyright.png')
        ## image.paste(copyright, (5, size[1] - 14))
        text = ', '.join(COPYRIGHT)
        draw.rectangle([5, size[1] - 14, 222, size[1] - 7],
                       fill=0xff)
        draw.text((5, size[1] - 15), text, font=font)
    out = StringIO.StringIO()
    image.save(out, image.format)
    return out.getvalue()
    

def handle_request(request):                                      
    data = 'abracadabra'                                          
    return {'status': 0, 'data': data, 'length': len(data)}

def read_csv_config(path):
    fieldnames = [('zoom', int), ('lon', float), ('lat', float),
                  ('wlon', float), ('wlat', float), ('w', int), ('h', int)]
    reader = csv.DictReader(open(path), fieldnames=zip(*fieldnames)[0])
    for line in reader:
        for key, type_ in fieldnames:
            line[key] = type_(line[key])
        zoom = line.pop('zoom')
        ICONINFO[zoom] = line

def dispatcher():
    yield 1
    incoming = fibra.Tube("incoming")
    done = fibra.Tube("done")
    limit = int(config.get('map.limit', 100))
    while True:
        try:
            connection, address = yield incoming.pop()
            request = yield connection.recv_frame()
            print "%.4f| | incoming request" % time.time()
            try:
                request = pickle.loads(request)
                dispatch = {
                    protocols.labels.icon: icon,
                    protocols.labels.tile: tile,
                    protocols.labels.staticmaps: staticmaps,
                    }
                label = request['label']
                start = time.time()
                response = dispatch[label](request)
                print "%.4f | overall | %.4f " % (time.time(), (time.time() - start))
            except NotImplementedError:
                traceback.print_exc()
                response = pickle.dumps(dict(status=protocols.status.NOTIMPLEMENTED))
            except Exception:
                traceback.print_exc()
                response = pickle.dumps(dict(status=protocols.status.ERROR, data=traceback.format_exc()))
            yield connection.send_frame(response)
        except Exception, exc:
            traceback.print_exc()
        if styles.counter > limit:
            print "Limit of %d map objects reached, shutting down" % limit
            sys.exit(-2)
        yield done.push(True)

def listen(address):
    """Listen on address, and spawn accept_task when a connection is received."""
    incoming = fibra.Tube("incoming")
    done = fibra.Tube("done")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(0)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(address)
    sock.listen(5)
    while True:
        yield fibra.Read(sock)
        conn, address = sock.accept()
        yield incoming.push((fibra.net.Transport(conn), address))
        wait = yield done.pop('done')

def analyze_mem():
    while True:
        yield 10
        print "Quantity of objects marked as garbage: %d" % len(gc.garbage)

def main(args):
    cfg = render.config.Config(args.config)
    logging.config.fileConfig(cfg.get('logging.path', '/etc/renderd/loggers.ini'))
    read_csv_config(config.get('map_elements.path',
                               '/etc/renderd/map_elements.csv'))
    mapnik.register_plugins(config.get('mapnik.input', '/usr/lib/mapnik/input'))
    mapnik.register_fonts(config.get('mapnik.fonts', '/usr/lib/mapnik/fonts'))
    schedule = fibra.schedule()
    schedule.install(listen((args.host, args.port)))
    schedule.install(dispatcher())
    schedule.run()

if __name__ == '__main__':
    parser = argparse.ArgumentParser('renderd')
    parser.add_argument('-c', '--config', default='/etc/renderd/settings.ini',
                        type=argparse.FileType('r'))
    parser.add_argument('-H', '--host', default='127.0.0.1')
    parser.add_argument('-P', '--port', default=10001, type=int)
    args = parser.parse_args()
    main(args)
    # cProfile.runctx('main()', globals(), locals(), '/tmp/stats')
